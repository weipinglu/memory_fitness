<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Number Recall Trainer</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { margin: 24px; display: grid; gap: 16px; place-items: start; }
    main { width: min(720px, 100%); display: grid; gap: 16px; }
    h1 { font-size: 1.25rem; margin: 0; }
    .grid { display: grid; gap: 12px; }
    .panel { padding: 12px; border: 1px solid #e5e5e5; border-radius: 12px; background: #fafafa; }
    .fields { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; }
    label { display: grid; gap: 6px; font-size: 0.95rem; }
    select, input[type="number"], input[type="range"] {
      padding: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem;
      background: white;
    }
    .fields select,
    .fields input[type="number"] {
      width: 100%;
      box-sizing: border-box;
    }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type="number"] { -moz-appearance: textfield; }
    .checkbox { display: flex; align-items: center; gap: 8px; }
    .controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .control-buttons { display: flex; gap: 12px; }
    .counter-group { display: flex; align-items: center; gap: 8px; margin-left: auto; }
    button {
      padding: 12px 16px; font-size: 1rem; border-radius: 10px; border: 1px solid #ccc; cursor: pointer; background: white;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .controls button { padding: 8px 12px; font-size: 0.95rem; border-radius: 8px; }
    .speed-control { display: flex; align-items: center; gap: 12px; }
    .speed-buttons { margin-left: auto; display: flex; gap: 8px; flex-wrap: nowrap; }
    .speed-buttons button { padding: 4px 10px; font-size: 0.85rem; white-space: nowrap; }
    .speed-buttons button.active {
      background: #333;
      color: #fff;
      border-color: #333;
    }
    .digits-control { display: flex; gap: 8px; align-items: center; }
    .digits-control input { flex: 1; }
    .digits-buttons { display: flex; gap: 8px; }
    .digits-buttons button { width: 52px; padding-inline: 0; font-size: 1.1rem; }
    .big { font-size: 1.8rem; letter-spacing: 0.04em; word-spacing: 0.2em; }
    .meta { color: #555; font-size: 0.95rem; }
    .row { display: flex; align-items: center; gap: 8px; }
    .value-badge { min-width: 3ch; display: inline-block; text-align: right; }
    .counter-badge { font-weight: 600; font-size: 1.1rem; }
  </style>
</head>
<body>
<main>
  <h1 data-i18n="title">Number Recall Trainer</h1>

  <!-- Settings -->
  <section class="panel grid" aria-label="settings">
    <div class="fields">
      <label>
        <span data-i18n="label.language">Language</span>
        <select id="langSelect">
          <option value="en-US" data-i18n="lang.en">English (en-US)</option>
          <option value="zh-CN" data-i18n="lang.zh-cn">‰∏≠ÊñáÔºàÊôÆÈÄöËØù, zh-CNÔºâ</option>
        </select>
      </label>

      <label>
        <span data-i18n="label.voice">Voice</span>
        <select id="voiceSelect">
          <option value="" data-i18n="option.voice.auto">Auto (best available)</option>
        </select>
      </label>

      <label>
        <span data-i18n="label.digits">Number of digits</span>
        <div class="digits-control">
          <input id="digitsInput" type="number" min="1" max="24" value="6" />
          <div class="digits-buttons">
            <button id="digitsDec" type="button" aria-label="Decrease digits">‚àí</button>
            <button id="digitsInc" type="button" aria-label="Increase digits">+</button>
          </div>
        </div>
      </label>

      <label class="speed-control">
        <span data-i18n="label.speed">Voice speed:</span>
        <div class="speed-buttons" role="group" aria-label="Voice speed">
          <button type="button" data-rate="0.5" data-i18n="speed.low">Low</button>
          <button type="button" data-rate="1" data-i18n="speed.normal">Normal</button>
          <button type="button" data-rate="1.5" data-i18n="speed.fast">Fast</button>
        </div>
      </label>
    </div>

  </section>

  <!-- Controls -->
  <section class="controls">
    <div class="control-buttons">
      <button id="speakBtn" data-i18n="button.speak">Start (Speak)</button>
      <button id="revealBtn" data-i18n="button.reveal" disabled>Reveal</button>
    </div>
    <div class="control-buttons">
      <button id="micBtn">üé§ Microphone</button>
    </div>
    <div class="counter-group">
      <span data-i18n="counter.label">Sessions started:</span>
      <span id="startCountOut" class="counter-badge" aria-live="polite">0</span>
      <button id="resetCountBtn" type="button" data-i18n="button.resetCounter">Reset</button>
    </div>
  </section>

  <!-- Output -->
  <section class="panel grid">
    <div class="meta" data-i18n="meta.current">Current number:</div>
    <div id="numberOut" class="big" aria-live="polite">‚Äî</div>
    <div class="meta" data-i18n="meta.userSpoken">User spoken number:</div>
    <div id="userSpokenOut" class="big" aria-live="polite">‚Äî</div>
    <div class="meta"><span data-i18n="meta.elapsed">Elapsed since spoken:</span> <span id="elapsedOut">‚Äî</span></div>
  </section>
</main>

<script>
  // ---------- State ----------
  let currentDigits = null;
  let t0 = null;            // timestamp (performance.now) when speech ended
  let speaking = false;
  let voicesCache = [];
  let recognition = null;
  let isListening = false;
  let recognizedDigits = [];
  let processedResultIndex = 0;
  let beepDelaySeconds = 1; // Delay in seconds before beep plays (default 1)
  let stopDelaySeconds = 1; // Delay in seconds after stop button click before actually stopping (default 1)

  // ---------- Elements ----------
  const langSelect = document.getElementById('langSelect');
  const voiceSelect = document.getElementById('voiceSelect');
  const digitsInput = document.getElementById('digitsInput');
  const digitsDec = document.getElementById('digitsDec');
  const digitsInc = document.getElementById('digitsInc');
  const rateButtons = Array.from(document.querySelectorAll('.speed-buttons button'));
  const speedButtonsGroup = document.querySelector('.speed-buttons');
  const speakBtn = document.getElementById('speakBtn');
  const revealBtn = document.getElementById('revealBtn');
  const micBtn = document.getElementById('micBtn');
  const numberOut = document.getElementById('numberOut');
  const userSpokenOut = document.getElementById('userSpokenOut');
  const elapsedOut = document.getElementById('elapsedOut');
  const startCountOut = document.getElementById('startCountOut');
  const resetCountBtn = document.getElementById('resetCountBtn');

  const FALLBACK_LANG = 'en-US';
  const I18N_STRINGS = {
    'en-US': {
      title: 'Number Recall Trainer',
      'label.language': 'Language',
      'label.voice': 'Voice',
      'label.digits': 'Number of digits',
      'label.speed': 'Voice speed:',
      'speed.low': 'Low',
      'speed.normal': 'Normal',
      'speed.fast': 'Fast',
      'button.speak': 'Start (Speak)',
      'button.reveal': 'Reveal',
      'button.mic': 'üé§ Microphone',
      'button.micListening': 'üõë Stop Recording',
      'button.resetCounter': 'Reset',
      'meta.current': 'Current number:',
      'meta.userSpoken': 'User spoken number:',
      'meta.elapsed': 'Elapsed since spoken:',
      'counter.label': 'Sessions started:',
      'option.voice.auto': 'Auto (best available)',
      'digits.decrease': 'Decrease digits',
      'digits.increase': 'Increase digits',
      'lang.en': 'English (en-US)',
      'lang.zh-cn': '‰∏≠ÊñáÔºàÊôÆÈÄöËØù, zh-CNÔºâ'
    },
    'zh-CN': {
      title: 'Êï∞Â≠óËÆ∞ÂøÜËÆ≠ÁªÉÂô®',
      'label.language': 'ËØ≠Ë®Ä',
      'label.voice': 'ËØ≠Èü≥',
      'label.digits': 'Êï∞Â≠ó‰ΩçÊï∞',
      'label.speed': 'ËØ≠ÈÄüÔºö',
      'speed.low': 'ÊÖ¢ÈÄü',
      'speed.normal': 'Ê≠£Â∏∏',
      'speed.fast': 'Âø´ÈÄü',
      'button.speak': 'ÂºÄÂßãÊí≠Êä•',
      'button.reveal': 'Êè≠Á§∫',
      'button.mic': 'üé§ È∫¶ÂÖãÈ£é',
      'button.micListening': 'üõë ÂÅúÊ≠¢ÂΩïÈü≥',
      'button.resetCounter': 'ÈáçÁΩÆ',
      'meta.current': 'ÂΩìÂâçÊï∞Â≠óÔºö',
      'meta.userSpoken': 'Áî®Êà∑ËØ¥Âá∫Êï∞Â≠óÔºö',
      'meta.elapsed': 'ËØ≠Èü≥ÁªìÊùüÂêéÁªèËøáÊó∂Èó¥Ôºö',
      'counter.label': 'Â∑≤ÂºÄÂßãÊ¨°Êï∞Ôºö',
      'option.voice.auto': 'Ëá™Âä®ÔºàÊúÄ‰ºòÔºâ',
      'digits.decrease': 'ÂáèÂ∞ë‰ΩçÊï∞',
      'digits.increase': 'Â¢ûÂä†‰ΩçÊï∞',
      'lang.en': 'Ëã±ËØ≠ (en-US)',
      'lang.zh-cn': '‰∏≠ÊñáÔºàÊôÆÈÄöËØù, zh-CNÔºâ'
    }
  };
  function translate(key, lang) {
    const table = I18N_STRINGS[lang] || I18N_STRINGS[FALLBACK_LANG] || {};
    return table[key] ?? (I18N_STRINGS[FALLBACK_LANG] ? I18N_STRINGS[FALLBACK_LANG][key] : key) ?? key;
  }

  function applyTranslations(lang) {
    const locale = I18N_STRINGS[lang] ? lang : FALLBACK_LANG;

    document.querySelectorAll('[data-i18n]').forEach(el => {
      const key = el.dataset.i18n;
      if (!key) return;
      const text = translate(key, locale);
      if (typeof text === 'string') el.textContent = text;
    });

    const attrTargets = [
      { el: digitsDec, attr: 'aria-label', key: 'digits.decrease' },
      { el: digitsInc, attr: 'aria-label', key: 'digits.increase' },
      { el: speakBtn, attr: 'aria-label', key: 'button.speak' },
      { el: revealBtn, attr: 'aria-label', key: 'button.reveal' },
      { el: resetCountBtn, attr: 'aria-label', key: 'button.resetCounter' },
      { el: speedButtonsGroup, attr: 'aria-label', key: 'label.speed' }
    ];
    attrTargets.forEach(({ el, attr, key }) => {
      if (!el) return;
      const text = translate(key, locale);
      if (typeof text === 'string') el.setAttribute(attr, text);
    });

    // Update microphone button text and aria-label based on listening state
    if (micBtn) {
      const micKey = isListening ? 'button.micListening' : 'button.mic';
      micBtn.textContent = translate(micKey, locale);
      micBtn.setAttribute('aria-label', translate(micKey, locale));
    }

    document.title = translate('title', locale);
  }

  let currentRate = 1;
  let startCount = 0;

  function setRateState(rate) {
    const value = Number(rate);
    const fallback = rateButtons.find(btn => Number(btn.dataset.rate) === 1) || rateButtons[0] || null;
    const target = rateButtons.find(btn => Number(btn.dataset.rate) === value) || fallback;
    currentRate = target ? Number(target.dataset.rate) : 1;

    rateButtons.forEach(btn => {
      const isActive = btn === target;
      btn.classList.toggle('active', isActive);
      btn.setAttribute('aria-pressed', String(isActive));
    });
  }

  function adjustDigits(delta) {
    const current = parseInt(digitsInput.value || '6', 10);
    const clamped = Math.max(1, Math.min(24, current + delta));
    digitsInput.value = clamped;
    saveSettings();
  }

  function updateStartCountDisplay() {
    if (startCountOut) startCountOut.textContent = String(startCount);
  }

  function incrementStartCount() {
    startCount += 1;
    updateStartCountDisplay();
    saveSettings();
  }

  function resetStartCount() {
    startCount = 0;
    updateStartCountDisplay();
    saveSettings();
  }

  // ---------- Persistence ----------
  const SETTINGS_KEY = 'nr_settings_v1';
  function loadSettings() {
    try {
      const raw = localStorage.getItem(SETTINGS_KEY);
      if (!raw) return;
      const s = JSON.parse(raw);
      if (s.lang) langSelect.value = s.lang;
      if (s.voiceURI) voiceSelect.value = s.voiceURI;
      if (Number.isFinite(s.n)) digitsInput.value = s.n;
      if (Number.isFinite(s.rate)) setRateState(s.rate);
      if (Number.isFinite(s.startCount)) startCount = s.startCount;
    } catch {}
  }
  function saveSettings() {
    const s = {
      lang: langSelect.value,
      voiceURI: voiceSelect.value,
      n: parseInt(digitsInput.value || '6', 10),
      rate: currentRate,
      startCount
    };
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));
  }

  // ---------- Utilities ----------
  function randomNDigitString(n, allowZeroLead = false) {
    if (n <= 0) return "";
    let s = "";
    for (let i = 0; i < n; i++) {
      let digit = Math.floor(Math.random() * 10);
      if (i === 0 && !allowZeroLead) {
        while (digit === 0) digit = Math.floor(Math.random() * 10);
      }
      if (i > 0) {
        while (digit === Number(s[i - 1])) digit = Math.floor(Math.random() * 10);
      }
      s += digit;
    }
    return s;
  }

  const zhMap = { "0":"Èõ∂", "1":"‰∏Ä", "2":"‰∫å", "3":"‰∏â", "4":"Âõõ", "5":"‰∫î", "6":"ÂÖ≠", "7":"‰∏É", "8":"ÂÖ´", "9":"‰πù" };
  function toChineseDigits(digs) { return digs.split("").map(d => zhMap[d] ?? d).join(""); }

  function spokenForm(digs, lang, perDigitMode) {
    // Per-digit mode: speak each digit distinctly
    if (perDigitMode) {
      if (lang.startsWith('zh')) {
        // Use Chinese numerals with Chinese comma for cadence
        return toChineseDigits(digs).split("").join("„ÄÅ");
      } else {
        return digs.split("").join(", ");
      }
    }
    // Whole string: let the TTS engine decide how to read it
    if (lang.startsWith('zh')) {
      // In Chinese, to ensure digits aren‚Äôt read as a large number name, still convert to Chinese digits without separators
      return toChineseDigits(digs);
    }
    return digs;
  }

  function resetRound() {
    numberOut.textContent = '‚Äî';
    userSpokenOut.textContent = '‚Äî';
    elapsedOut.textContent = '‚Äî';
    currentDigits = null;
    t0 = null;
    // Stop microphone if listening
    if (isListening) {
      stopListening();
    }
    recognizedDigits = [];
    processedResultIndex = 0;
  }

  // ---------- Speech ----------
  function listVoices() {
    voicesCache = speechSynthesis.getVoices() || [];
    populateVoiceSelect();
  }

  function populateVoiceSelect() {
    const lang = langSelect.value;
    const filtered = voicesCache.filter(v => v.lang && v.lang.toLowerCase().startsWith(lang.toLowerCase()));
    const previous = voiceSelect.value;
    voiceSelect.innerHTML = '';

    const autoOpt = document.createElement('option');
    autoOpt.value = '';
    autoOpt.dataset.i18n = 'option.voice.auto';
    autoOpt.textContent = translate('option.voice.auto', lang);
    voiceSelect.appendChild(autoOpt);

    filtered.forEach(v => {
      const opt = document.createElement('option');
      opt.value = v.voiceURI || v.name || '';
      opt.textContent = `${v.name} (${v.lang})`;
      voiceSelect.appendChild(opt);
    });

    // Try to keep previous selection if it still exists
    if ([...voiceSelect.options].some(o => o.value === previous)) {
      voiceSelect.value = previous;
    } else {
      voiceSelect.value = '';
    }
  }

  function chooseVoice(lang, voiceURI) {
    if (!voicesCache.length) return null;
    if (voiceURI) {
      const exact = voicesCache.find(v => (v.voiceURI === voiceURI) || (v.name === voiceURI));
      if (exact) return exact;
    }
    // Fallback: first voice matching language
    const matchLang = voicesCache.find(v => v.lang && v.lang.toLowerCase().startsWith(lang.toLowerCase()));
    if (matchLang) return matchLang;
    // Last resort: default voice
    return speechSynthesis.getVoices()[0] || null;
  }

  function speakText(text, langCode, rate, voiceURI, onend) {
    try {
      window.speechSynthesis.cancel(); // stop any previous speech

      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = langCode;
      utter.rate = rate;

      const chosen = chooseVoice(langCode, voiceURI);
      if (chosen) utter.voice = chosen;

      utter.onend = () => {
        speaking = false;
        t0 = performance.now(); // start timing when speech actually ends
        if (typeof onend === 'function') onend();
      };
      utter.onerror = () => {
        speaking = false;
        t0 = performance.now(); // still start timer for usability
      };

      speaking = true;
      window.speechSynthesis.speak(utter);
    } catch {
      speaking = false;
      t0 = performance.now();
      if (typeof onend === 'function') onend();
    }
  }

  // ---------- Events ----------
  // Persist on changes
  rateButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      setRateState(Number(btn.dataset.rate));
      saveSettings();
    });
  });
  digitsDec.addEventListener('click', () => adjustDigits(-1));
  digitsInc.addEventListener('click', () => adjustDigits(1));
  resetCountBtn.addEventListener('click', resetStartCount);

  [langSelect, voiceSelect, digitsInput].forEach(el => {
    el.addEventListener('change', saveSettings);
  });

  // Refresh voices when language changes
  langSelect.addEventListener('change', () => {
    populateVoiceSelect();
    applyTranslations(langSelect.value);
    // Update recognition language if listening
    if (recognition && isListening) {
      recognition.lang = langSelect.value;
    }
  });

  // Start (Speak)
  speakBtn.addEventListener('click', () => {
    resetRound();
    incrementStartCount();

    const n = Math.max(1, Math.min(24, parseInt(digitsInput.value || '6', 10)));
    const lang = langSelect.value;
    const rate = currentRate;
    const voiceURI = voiceSelect.value || '';

    currentDigits = randomNDigitString(n, false);
    const toSpeak = spokenForm(currentDigits, lang, true);

    speakBtn.disabled = true;
    revealBtn.disabled = true;

    speakText(toSpeak, lang, rate, voiceURI, () => {
      speakBtn.disabled = false;
      revealBtn.disabled = false;
    });
  });

  // Reveal
  revealBtn.addEventListener('click', () => {
    if (!currentDigits) return;

    // If still speaking, stop and mark time if needed
    if (speaking) {
      window.speechSynthesis.cancel();
      speaking = false;
      if (!t0) t0 = performance.now();
    }

    numberOut.textContent = currentDigits;

    const now = performance.now();
    const elapsedSec = t0 ? (now - t0) / 1000 : 0;
    elapsedOut.textContent = `${elapsedSec.toFixed(2)} s`;

    // Optional: keep Reveal enabled if you want to re-check time; here we disable to prevent double-click confusion
    revealBtn.disabled = true;
  });

  // ---------- Audio Feedback ----------
  function playBeep() {
    try {
      // Create a short beep sound using Web Audio API
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      // Configure beep: 800Hz frequency, 200ms duration, pleasant tone
      oscillator.frequency.value = 800;
      oscillator.type = 'sine'; // Sine wave for smooth beep
      
      // Fade out to avoid clicking sound
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.2);
      
      console.log('üîî Beep played - recognition ready');
    } catch (e) {
      console.warn('Could not play beep:', e);
    }
  }

  // ---------- Speech Recognition ----------
  function initSpeechRecognition() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      console.warn('Speech Recognition not supported in this browser');
      if (micBtn) micBtn.disabled = true;
      return null;
    }

    const rec = new SpeechRecognition();
    
    // Set up grammar to only recognize digits - this improves accuracy significantly
    // Check if browser supports grammars (Chrome/Edge support it, Safari doesn't)
    let grammarSupported = false;
    if ('webkitSpeechGrammarList' in window || 'SpeechGrammarList' in window) {
      try {
        const SpeechGrammarList = window.SpeechGrammarList || window.webkitSpeechGrammarList;
        const grammarList = new SpeechGrammarList();
        
        // Define grammar: only single digits 0-9 (spoken as words or numbers)
        // Using JSGF format (Java Speech Grammar Format)
        // Note: Grammar may not fully constrain - some engines still use full vocabulary
        // but give higher weight to grammar matches
        const grammar = '#JSGF V1.0; grammar digits; public <digit> = (zero | one | two | three | four | five | six | seven | eight | nine) | ([0-9]);';
        
        // Set weight (0.0 to 1.0, higher = more likely to be recognized)
        grammarList.addFromString(grammar, 1.0);
        rec.grammars = grammarList;
        grammarSupported = true;
        console.log('‚úì Grammar configured successfully');
      } catch (e) {
        console.warn('‚úó Grammar setup failed:', e);
      }
    } else {
      console.log('‚ö† Grammar not supported in this browser, using general recognition');
    }
    
    rec.continuous = true;
    rec.interimResults = false;
    rec.lang = langSelect.value;
    
    console.log('Recognition initialized:', {
      continuous: rec.continuous,
      interimResults: rec.interimResults,
      lang: rec.lang,
      grammarSupported: grammarSupported
    });

    rec.onresult = (event) => {
      // Process each result individually
      const resultCount = event.results.length;
      
      console.log(`üì• onresult called: ${resultCount} results, processedIndex: ${processedResultIndex}, isListening: ${isListening}`);
      
      // IMPORTANT: Process results even if we've stopped - results may arrive after stop()
      // This is normal behavior - stop() lets current recognition finish
      
      for (let i = processedResultIndex; i < resultCount; i++) {
        const result = event.results[i];
        
        console.log(`  [Result ${i}] isFinal: ${result.isFinal}, hasTranscript: ${!!result[0]}`);
        
        if (result[0]) {
          console.log(`    Transcript: "${result[0].transcript}"`);
        }
        
        if (result.isFinal && result[0]) {
          const transcript = result[0].transcript.trim();
          console.log(`  ‚úì Processing FINAL result ${i}: "${transcript}"`);
          
          // Extract ALL digits from the transcript
          const extractedDigits = [];
          
          // 1. Extract all numeric digits (most reliable)
          const numMatches = transcript.match(/[0-9]/g);
          if (numMatches) {
            console.log(`    Found numeric digits: [${numMatches.join(', ')}]`);
            extractedDigits.push(...numMatches);
          }
          
          // 2. Extract English digit words if no numeric digits found
          if (extractedDigits.length === 0) {
            console.log(`    No numeric digits, checking word digits...`);
            const lower = transcript.toLowerCase();
            const wordMap = {
              'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4',
              'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9'
            };
            
            const words = lower.split(/\s+/);
            console.log(`    Split into words: [${words.join(', ')}]`);
            for (const word of words) {
              const cleanWord = word.replace(/[^\w]/g, '');
              if (wordMap[cleanWord]) {
                console.log(`    ‚úì Matched word "${word}" -> "${wordMap[cleanWord]}"`);
                extractedDigits.push(wordMap[cleanWord]);
              }
            }
          }
          
          // 3. Extract Chinese digits
          const chineseMatches = transcript.match(/[Èõ∂‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πù]/g);
          if (chineseMatches) {
            console.log(`    Found Chinese digits: [${chineseMatches.join(', ')}]`);
            const chineseMap = {
              'Èõ∂': '0', '‰∏Ä': '1', '‰∫å': '2', '‰∏â': '3', 'Âõõ': '4',
              '‰∫î': '5', 'ÂÖ≠': '6', '‰∏É': '7', 'ÂÖ´': '8', '‰πù': '9'
            };
            for (const chinese of chineseMatches) {
              if (chineseMap[chinese]) {
                extractedDigits.push(chineseMap[chinese]);
              }
            }
          }
          
          console.log(`    Total extracted digits: [${extractedDigits.join(', ')}]`);
          
          // Add all extracted digits (process even if we've stopped - may arrive late)
          if (extractedDigits.length > 0) {
            for (const digit of extractedDigits) {
              recognizedDigits.push(digit);
            }
            console.log(`    ‚úì Added to recognizedDigits. New total: "${recognizedDigits.join('')}"`);
            
            // If we've already stopped, update the display now
            if (!isListening && userSpokenOut) {
              const finalNumber = recognizedDigits.join('');
              userSpokenOut.textContent = finalNumber;
              currentDigits = finalNumber;
              t0 = performance.now();
              console.log(`    ‚Üª Updated display after stop: "${finalNumber}"`);
            }
          } else {
            console.log(`    ‚úó No digits extracted from transcript: "${transcript}"`);
            console.log(`    ‚ö† Grammar may not be working - received non-digit: "${transcript}"`);
          }
          
          // Update processed index
          processedResultIndex = i + 1;
          console.log(`    Updated processedResultIndex to: ${processedResultIndex}`);
        }
      }
    };

    rec.onerror = (event) => {
      console.error('‚ùå Speech recognition error:', event.error);
      console.error('  Error details:', {
        error: event.error,
        message: event.message,
        isListening: isListening
      });
      if (event.error === 'no-speech' || event.error === 'aborted') {
        // These are normal, don't show error to user
        console.log('  (Normal error, continuing...)');
        return;
      }
      stopListening();
    };

    rec.onend = () => {
      console.log('üîö Recognition ended');
      console.log('  isListening:', isListening);
      
      // If we're still supposed to be listening, restart after a short delay
      if (isListening && recognition) {
        // Reset processedResultIndex when restarting - results array resets on restart
        processedResultIndex = 0;
        console.log('  ‚Üª Will restart, reset processedResultIndex to 0');
        setTimeout(() => {
          if (isListening && recognition) {
            try {
              console.log('  ‚Üª Restarting recognition...');
              recognition.start();
              console.log('  ‚úì Restart successful');
            } catch (e) {
              console.warn('  ‚úó Restart failed:', e);
              // Recognition might already be starting, ignore
            }
          }
        }, 100);
      } else {
        processedResultIndex = 0;
        console.log('  ‚úì Stopped, reset processedResultIndex to 0');
      }
    };

    return rec;
  }

  function startListening() {
    if (!recognition) {
      recognition = initSpeechRecognition();
      if (!recognition) return;
    }

    // Reset everything for a fresh start
    recognizedDigits = [];
    processedResultIndex = 0;
    userSpokenOut.textContent = '...'; // Show indication that recording is active
    isListening = true;
    recognition.lang = langSelect.value;

    // Stop any existing recognition first and wait for it to fully stop
    try {
      recognition.stop();
    } catch (e) {
      // Ignore if not running
    }

    // Start recognition after a brief pause to ensure clean start
    setTimeout(() => {
      if (isListening && recognition) {
        try {
          console.log('üé§ Starting recognition...');
          console.log('  State before start:', {
            isListening: isListening,
            processedResultIndex: processedResultIndex,
            recognizedDigits: recognizedDigits,
            lang: recognition.lang
          });
          recognition.start();
          micBtn.textContent = translate('button.micListening', langSelect.value);
          micBtn.setAttribute('aria-label', translate('button.micListening', langSelect.value));
          console.log('‚úì Recognition started successfully');
          
          // Play beep N seconds after button click to indicate recognition is ready
          setTimeout(() => {
            if (isListening) {
              playBeep();
            }
          }, beepDelaySeconds * 1000);
        } catch (e) {
          console.error('‚úó Failed to start recognition:', e);
          if (e.name === 'InvalidStateError' || (e.message && e.message.includes('aborted'))) {
            setTimeout(() => {
              if (isListening && recognition) {
                try {
                  console.log('üîÑ Retrying recognition start...');
                  recognition.start();
                  console.log('‚úì Retry successful');
                } catch (e2) {
                  console.error('‚úó Retry failed:', e2);
                  isListening = false;
                }
              }
            }, 300);
          } else {
            isListening = false;
          }
        }
      }
    }, 150);
  }

  function stopListening() {
    console.log('üõë Stop button clicked - waiting before stopping...');
    console.log('  Current state:', {
      recognizedDigits: recognizedDigits,
      count: recognizedDigits.length,
      joined: recognizedDigits.join('')
    });
    
    // Update button immediately for user feedback
    micBtn.textContent = translate('button.mic', langSelect.value);
    micBtn.setAttribute('aria-label', translate('button.mic', langSelect.value));
    
    // Wait for delay before actually stopping (gives time for last digit to be processed)
    setTimeout(() => {
      console.log(`‚è±Ô∏è Stop delay (${stopDelaySeconds}s) elapsed - stopping recognition now`);
      
      isListening = false;
      if (recognition) {
        try {
          recognition.stop();
          console.log('‚úì Recognition.stop() called');
        } catch (e) {
          console.warn('‚ö† Error stopping recognition:', e);
        }
      }
      
      // Wait a bit more for any final results to arrive, then update display
      setTimeout(() => {
        if (recognizedDigits.length > 0) {
          const finalNumber = recognizedDigits.join('');
          userSpokenOut.textContent = finalNumber;
          currentDigits = finalNumber;
          t0 = performance.now();
          console.log(`‚úÖ Final display updated: "${finalNumber}"`);
        } else {
          userSpokenOut.textContent = '‚Äî';
          console.log('‚ö† No digits recognized, showing "‚Äî"');
        }
      }, 300); // Small additional delay for final results
    }, stopDelaySeconds * 1000); // Wait configured delay before stopping
  }

  // Microphone button click handler
  micBtn.addEventListener('click', () => {
    if (isListening) {
      stopListening();
    } else {
      startListening();
    }
  });

  // ---------- Init ----------
  loadSettings();
  applyTranslations(langSelect.value);
  updateStartCountDisplay();
  setRateState(currentRate);

  // Voice enumeration is async in some browsers; handle both paths
  listVoices();
  if (typeof speechSynthesis !== 'undefined') {
    speechSynthesis.onvoiceschanged = () => {
      listVoices();
      populateVoiceSelect();
    };
  }
</script>
</body>
</html>
